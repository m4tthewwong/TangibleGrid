from flask import Flask, render_template, render_template_string
from flask_cors import CORS
from flask_socketio import SocketIO
from flask_socketio import send, emit
import serial
import json
import time
import pyttsx3
import speech_recognition as sr
import openai
import threading

openai.api_key = "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"

app = Flask(__name__)
CORS(app)
socketio = SocketIO(app, cors_allowed_origins='*')
#serialPort = "/dev/cu.usbserial-14120"
# COMMENT FOR FAKE SERIAL ----------------------------------------------------------------
#serialPort = "COM4"
#ser = serial.Serial(serialPort, baudrate=9600, timeout=0.5)
# COMMENT FOR FAKE SERIAL ----------------------------------------------------------------
engine = pyttsx3.init()
engine.say("System initialize")
engine.runAndWait()
engine.stop()

r = sr.Recognizer()

# dictionary mapping {bracket location : bracket info}
data_list = {}

# html code generated by chatgpt
curr_code = None

# fake time - idk if this is working properly
sec = 0

def get_initial_html():
    prompt = (
        "Suppose I have a CSS grid with 12 columns and 16 rows. This grid represents the layout of a webpage to be generated. "
        "I also have different types of brackets: text, figure, and video. I want the layout of a webpage to be generated. "
        "I want the width of the webpage to always be the width of the current window. "
        "I want the height of the webpage to always be 4/3 times the width of the webpage. "
        "Make sure to provide the complete code for the webpage. "
        "Also, make sure you only provide code and nothing else besides that. "
        "The webpage should initially be empty. "
        "Add this code to the HTML code: "
        "socket.on('connect', function () {\n"
        "    socket.emit('get data');\n"
        "}); "
        "socket.on('loop', function () {\n"
        "    socket.emit('get data');\n"
        "}); "
        "socket.on('update_html', function (data) {\n"
        "    document.body.innerHTML = data.html;\n"
        "}); "
        "Also use this: <script src=\"https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js\" "
        "integrity=\"sha512-q/dWJ3kcmjBLU4Qc47E4A9kTB4m3wuTY7vkFJDTZKjTs8jhyGQnaUrxa0Ytd0ssMZhbNua9hE+E7Qv1j+DyZwA==\" "
        "crossorigin=\"anonymous\"></script>"
    )

    html_code = chat(prompt)
    return html_code

@app.route('/')
def index():  # put application's code here
    global curr_code
    print("System launch!")
    initial_html = get_initial_html()
    curr_code = initial_html
    print(curr_code)
    print("Rendered initial template")
    #socketio.start_background_task(send_data, app)
    #return initial_html
    return render_template_string(initial_html)
    #return render_template('index.html')

"""@socketio.on('web connected')
def handle_my_custom_event(message):
    print(str(message))"""
    
def handle_button_pressed():
    print("Button pressed. Starting audio recording...")
    r = sr.Recognizer()
    with sr.Microphone() as source:
        print("Recording...")
        audio_data = r.record(source, duration=5)  # record audio for certain number of seconds
        print("Recording finished. Converting speech to text...")
        try:
            text = r.recognize_google(audio_data)
            print("Conversion finished. Text: " + text)
        except sr.UnknownValueError:
            print("Speech Recognition could not understand the audio")
            text = ""
            
        return text
        
@socketio.on('save info')
def handle_save_info(data):
    info = data.get('info')
    type = data.get('type')
    bracket = data.get('bracket')
    row_num = data.get('row_num')
    col_num = data.get('col_num')
    h_len = data.get('h_len')
    w_len = data.get('w_len')
    data_list[f"{type}, {bracket}, {row_num}, {col_num}, {h_len}, {w_len}"] = info
    
def chat(prompt):
    response = openai.chat.completions.create(
        model = "gpt-3.5-turbo",
        messages=[{"role" : "user", "content" : prompt}]
    )
    return response.choices[0].message.content.strip()
    
@socketio.on('get data')
def send_data():
    global curr_code
    global sec
    def speak(text):
        engine = pyttsx3.init()
        engine.setProperty('rate', 170)
        engine.say(text)
        engine.runAndWait()
        
    def speak_bracket_details(bracket, col_num, row_num, h_len, w_len):
        text = (
            bracket + "bracket detected" +
                    "                                                                        ," +
                    "location at" + str(col_num) + "                                        " +
                    str(row_num) +
                    "                                                                       ," +
                    "bracket row length" + "                              " + str(h_len) +
                    "                                                                       ," +
                    "bracket column length" + "                         " + str(w_len)
        )
        threading.Thread(target=speak, args=(text,)).start()
        
    print("Detecting new brackets...")
        
    # print("Receive data request from web.")
    # serialPort = "/dev/cu.usbserial-14220"
    # ser = serial.Serial(serialPort, baudrate=9600, timeout=0.5)
    # while ser.is_open:
    
    # UNCOMMENT FOR FAKE SERIAL ----------------------------------------------------------------
    # These are tests
    if sec >= 0 and sec <= 60:
        str_json = None
    if sec >= 60 and sec <= 120:
        str_json = """{"type":"add", "bracket":"text", "x":3, "y":3, "h":4, "w":4, "info":""}"""
    #if sec > 120:
        #str_json = """{"type":"add", "bracket":"text", "x":5, "y":5, "h":3, "w":6, "info":""}"""
    #{"type":"del", "bracket":"text", "x":3, "y":3, "h":4, "w":4}
    # UNCOMMENT FOR FAKE SERIAL ----------------------------------------------------------------
    
    # COMMENT FOR FAKE SERIAL ----------------------------------------------------------------
    #raw_data = ser.readline()
    #print("raw data from arduino: ", raw_data)
    #str_json = str(raw_data, encoding='utf-8')
    #print("string data: ", str_json)
    # COMMENT FOR FAKE SERIAL ----------------------------------------------------------------
    if str_json:
        if "type" in str_json:
            json_data = json.loads(str_json)
            type = json_data["type"]
            bracket = json_data["bracket"]
            row_num = json_data["x"]
            col_num = json_data["y"]
            h_len = json_data["h"]
            w_len = json_data["w"]
            info = json_data["info"]
            
            added_bracket = False
            
            if (bracket == "text") and (f"{type}, {bracket}, {row_num}, {col_num}, {h_len}, {w_len}" not in data_list):
                info = str(handle_button_pressed())
                data_list[f"{type}, {bracket}, {row_num}, {col_num}, {h_len}, {w_len}"] = info
                added_bracket = True
                
            info = data_list[f"{type}, {bracket}, {row_num}, {col_num}, {h_len}, {w_len}"]
            # note to self: might want to change how data_list stores the data to: type, bracket, row_num, col_num (or something else) - so that 
            # adjusting the bracket location doesn't affect the fact that the info is assigned to that text bracket
            
            if type == "add" and bracket == "text" and added_bracket:
                print(curr_code)
                prompt = (f"Now, I want you to add a text box that says '{info}'. The textbox should go from row '{row_num}' to row '{str(int(row_num) + int(h_len))}' and column '{col_num}' to column '{str(int(col_num) + int(w_len))}'. "
            "I want the text box to have a black border and a light grey background. "
            "I want to make the text color blue. "
            "I want the text to be bolded and italicized. "
            "I want the text to be 24px Arial and centered in the text box."
            f"This is the code that I want you to change: {curr_code}")
                html_code = chat(prompt)
                curr_code = html_code
                #with app.app_context():
                print("updating code...")
                new_code = render_template_string(html_code)
                socketio.emit('update_html', {'html': new_code})
            
                
            
            """emit("data transmit", {
                "type": type,
                "bracket": bracket,
                "row_num": row_num,
                "col_num": col_num,
                "h_len": h_len,
                "w_len": w_len,
                "info": info,
            })"""
            print(type, bracket, row_num, col_num, h_len, w_len, info)
            
            #emit("loop")
                
            #if type == "add" and added_bracket:
                #speak_bracket_details(bracket, col_num, row_num, h_len, w_len)
        
            time.sleep(1)
            # engine.endLoop()
            # ser.close()
    #else:
        #emit("pause")
        
    sec += 1
    emit("loop")
    #send_data(app)

if __name__ == '__main__':
    socketio.run(app)

